-- Create the event containing the location of all bases.
function create_history_event_snapshot()
    local result = {type="snapshot", bases{}}
    for _,base in pairs(get_all_bases()) do
        local guid = base.getGUID()
        local pos = base.getPosition()
        local rot = base.getRotation()
        result.bases[guid] =  {
          position={x=pos.x, y=pos.y, z=pos.z},
          rotation={x=rot.x, y=rot.y, z=rot.z}
        }
        --print("y=", data.position.y)
        table.insert(result, data)
    end
    return result
end

-- Restore the bases according to the snapshot
function apply_snapshot(snapshot)
  for guid,base_state in pairs(snapshot.bases) do
    local base = getObjectFromGUID(guid)
    if base == nil then
      print_error("Object no longer exists, was it deleted: " .. tostring(guid))
    else
      --print("base=", base)
      --print(base.getName())
      base.setPosition(base_state.position)
      base.setRotation(base_state.rotation)
    end
  end
  print("snapshot applied")
end



function do_record_snapshot()
  local snapshot = create_history_event_snapshot()
  local top = g_history_stack:current()
  if top ~= nil then
    for _,base in pairs(get_all_bases()) do
      local guid = base.getGUID()
      if snapshot[guid] == top[guid] then
        snapshot[guid] = nil
      end
    end
  end
  if is_table_empty(snapshot) then
    print("not differences in snapshot")
    return
  end
  g_history_stack:push(snapshot)
  print("snapshot saved ", g_history_stack:size())
end


-- When all the bases have stopped moving record a snapshot.
function record_snapshot_at_rest()
  while not are_all_bases_are_at_rest() do
      coroutine.yield(0)
  end
  print("bases are at rest")
  do_record_snapshot()
  return 1
end

-- Places an event for the current location of all bases on the
-- history stack
function history_record_snapshot()
  startLuaCoroutine(self, 'record_snapshot_at_rest')
end
